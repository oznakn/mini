grammar;

use std::str::FromStr;

use crate::ast;

match {
    ",",
    ".",
    ";",
    ":",
    "=",
    "+",
    "-",
    "!",
    "*",
    "/",
    "%",
    "==",
    "===",
    "!=",
    "!==",
    "<",
    "<=",
    ">",
    ">=",
    "&&",
    "||",
    "^^",
    "{",
    "}",
    "(",
    ")",
    "[",
    "]",
    "let",
    "const",
    "string",
    "number",

    "true",
    "false",
    "undefined",
    "null",

    "void",
    "function",
    "export",
    "import",
    "from",

    r"[0-9]+",
    r"[0-9]+\.[0-9]+",
    r"[a-zA-Z][a-zA-Z0-9]*",
    r"'[^\n\r']*'",
    r"`[^\n\r`]*`",

    // Skip whitespace and comments
    r"\s*" => { },
    r"//[^\n\r]*[\n\r]*" => { }, // `// comment`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { }, // `/* comment */`
}

CommaList<T>: Vec<T> = {
    <items: (<T> ",")*> <last: T?> => {
        let mut items = items;
        items.extend(last);
        items
    }
};

pub Program: ast::Program<'input> =
    <statements:StatementList> => ast::Program {
        statements,
    };

StatementList = <Statement*>;

Body = "{" <StatementList> "}";

Statement: ast::Statement<'input> = {
    <expression:Expression> ";" => ast::Statement::ExpressionStatement { expression },
    DefinitionStatement,
    FunctionStatement,
    ImportStatement,
    ExportStatement,
    BodyStatement,
};

BodyStatement: ast::Statement<'input> =
    <statements:Body> => ast::Statement::BodyStatement {
        statements
    };

ImportStatement: ast::Statement<'input> = {
    "import" <identifier:Identifier> "from" <s:String> ";" => {
        let from = match s {
            ast::Value::String(v) => Some(v),
            _ => None,
        };

        ast::Statement::ImportStatement {
            identifier: Some(identifier),
            from: from.unwrap(),
        }
    },

    "import" <s:String> ";" => {
        let from = match s {
            ast::Value::String(v) => Some(v),
            _ => None,
        };

        ast::Statement::ImportStatement {
            identifier: None,
            from: from.unwrap(),
        }
    },
};

ExportStatement: ast::Statement<'input> = {
    "export" <s:FunctionStatement> => ast::Statement::ExportStatement {
        statement: Box::new(s),
    },
    "export" "const" <definition:VariableDefinitionOptionalKind> "=" <e:Expression> ";" => ast::Statement::ExportStatement {
        statement: Box::new(ast::Statement::DefinitionStatement {
            is_const: true,
            variable: definition,
            expression: Some(e),
        }),
    },
};

FunctionStatement: ast::Statement<'input> = {
    "function" <identifier:Identifier> "(" <parameters:CommaList<VariableDefinition>> ")" <statements:Body> => ast::Statement::FunctionStatement {
        identifier,
        return_kind: None,
        parameters,
        statements,
    },
    "function" <identifier:Identifier> "(" <parameters:CommaList<VariableDefinition>> ")" ":" "void" <statements:Body> => ast::Statement::FunctionStatement {
        identifier,
        return_kind: None,
        parameters,
        statements,
    },
    "function" <identifier:Identifier> "(" <parameters:CommaList<VariableDefinition>> ")" ":" <return_kind:VariableKind> <statements:Body> => ast::Statement::FunctionStatement {
        identifier,
        return_kind: Some(return_kind),
        parameters,
        statements,
    },
};

DefinitionStatement: ast::Statement<'input> = {
    "let" <definition:VariableDefinition> ";" => ast::Statement::DefinitionStatement {
        is_const: false,
        variable: definition,
        expression: None,
    },
    "let" <definition:VariableDefinitionOptionalKind> "=" <e:Expression> ";" => ast::Statement::DefinitionStatement {
        is_const: false,
        variable: definition,
        expression: Some(e),
    },
    "const" <definition:VariableDefinition> ";" => ast::Statement::DefinitionStatement {
        is_const: true,
        variable: definition,
        expression: None,
    },
    "const" <definition:VariableDefinitionOptionalKind> "=" <e:Expression> ";" => ast::Statement::DefinitionStatement {
        is_const: true,
        variable: definition,
        expression: Some(e),
    },
}

Expression: ast::Expression<'input> = {
    AssignmentExpression,
    FunctionExpression,
    LogicalTerm,
};

FunctionExpression: ast::Expression<'input> = {
    "function" <identifier:Identifier> "(" <parameters:CommaList<VariableDefinition>> ")" <statements:Body> => ast::Expression::FunctionExpression {
        identifier: Some(identifier),
        return_kind: None,
        parameters,
        statements,
    },
    "function" <identifier:Identifier> "(" <parameters:CommaList<VariableDefinition>> ")" ":" "void" <statements:Body> => ast::Expression::FunctionExpression {
        identifier: Some(identifier),
        return_kind: None,
        parameters,
        statements,
    },
    "function" <identifier:Identifier> "(" <parameters:CommaList<VariableDefinition>> ")" ":" <return_kind:VariableKind> <statements:Body> => ast::Expression::FunctionExpression {
        identifier: Some(identifier),
        return_kind: Some(return_kind),
        parameters,
        statements,
    },
    "function" "(" <parameters:CommaList<VariableDefinition>> ")" <statements:Body> => ast::Expression::FunctionExpression {
        identifier: None,
        return_kind: None,
        parameters,
        statements,
    },
    "function" "(" <parameters:CommaList<VariableDefinition>> ")" ":" "void" <statements:Body> => ast::Expression::FunctionExpression {
        identifier: None,
        return_kind: None,
        parameters,
        statements,
    },
    "function" "(" <parameters:CommaList<VariableDefinition>> ")" ":" <return_kind:VariableKind> <statements:Body> => ast::Expression::FunctionExpression {
        identifier: None,
        return_kind: Some(return_kind),
        parameters,
        statements,
    },
}

AssignmentExpression: ast::Expression<'input> =
    <identifier:VariableIdentifier> "=" <e:Expression> => ast::Expression::AssignmentExpression {
        identifier,
        expression: Box::new(e),
    };

LogicalTerm: ast::Expression<'input> = {
    <left:LogicalTerm> <operator:LogicalOperator> <right:AddTerm> => ast::Expression::BinaryExpression {
        left: Box::new(left),
        operator,
        right: Box::new(right),
    },
    AddTerm,
};

AddTerm: ast::Expression<'input> = {
    <left:AddTerm> <operator:AddOperator> <right:MulTerm> => ast::Expression::BinaryExpression {
        left: Box::new(left),
        operator,
        right: Box::new(right),
    },
    MulTerm,
};

MulTerm: ast::Expression<'input> = {
    <left:MulTerm> <operator:MulOperator> <right:Factor> => ast::Expression::BinaryExpression {
        left: Box::new(left),
        operator,
        right: Box::new(right),
    },
    Factor,
};

Factor: ast::Expression<'input> = {
    <operator:UnaryOperator> <e:Factor> => ast::Expression::UnaryExpression {
        operator,
        expression: Box::new(e),
    },
    <value:Value> => ast::Expression::ValueExpression { value },
    <identifier:VariableIdentifier> => ast::Expression::VariableExpression { identifier },
    <identifier:VariableIdentifier> "(" <arguments:CommaList<Expression>> ")" => ast::Expression::CallExpression { identifier, arguments },
    "(" <e:Expression> ")" => e,
};

UnaryOperator: ast::UnaryOperator = {
    "+" => ast::UnaryOperator::Positive,
    "-" => ast::UnaryOperator::Negative,
    "!" => ast::UnaryOperator::Not,
};

AddOperator: ast::BinaryOperator = {
    "+" => ast::BinaryOperator::Addition,
    "-" => ast::BinaryOperator::Subtraction,
};

MulOperator: ast::BinaryOperator = {
    "*" => ast::BinaryOperator::Multiplication,
    "/" => ast::BinaryOperator::Division,
    "%" => ast::BinaryOperator::Mod,
};

LogicalOperator: ast::BinaryOperator = {
    "==" => ast::BinaryOperator::Equal,
    "===" => ast::BinaryOperator::StrictEqual,
    "!=" => ast::BinaryOperator::NotEqual,
    "!==" => ast::BinaryOperator::StrictNotEqual,
    "<" => ast::BinaryOperator::Less,
    "<=" => ast::BinaryOperator::LessEqual,
    ">" => ast::BinaryOperator::Greater,
    ">=" => ast::BinaryOperator::GreaterEqual,
    "&&" => ast::BinaryOperator::And,
    "||" => ast::BinaryOperator::Or,
    "^^" => ast::BinaryOperator::Xor,
};

VariableDefinition: ast::VariableDefinition<'input> = {
    <identifier:Identifier> ":" <kind:VariableKind> => ast::VariableDefinition {
        identifier,
        kind: Some(kind),
    },
}

VariableDefinitionOptionalKind: ast::VariableDefinition<'input> = {
    VariableDefinition,
    <identifier:Identifier> => ast::VariableDefinition {
        identifier,
        kind: None,
    },
}

VariableIdentifier: ast::VariableIdentifier<'input> = {
    <identifier:Identifier> => ast::VariableIdentifier::Identifier(identifier),
    <base:VariableIdentifier> "." <property:Identifier> => ast::VariableIdentifier::Property {
        base: Box::new(base),
        property,
    },
    <base:VariableIdentifier> "[" <index:Expression> "]" => ast::VariableIdentifier::Index { base: Box::new(base), index: Box::new(index) },
};

Identifier: &'input str =
    <name:r"[a-zA-Z][a-zA-Z0-9]*"> => name;

String: ast::Value<'input> = {
    <value:r"'[^\n\r']*'"> => ast::Value::String(&<>[1..<>.len()-1]),
    <value:r"`[^\n\r`]*`"> => ast::Value::String(&<>[1..<>.len()-1]),
};

Number: ast::Value<'input> = {
    <value:r"[0-9]+"> => ast::Value::Integer(u64::from_str(<>).unwrap()),
    <value:r"[0-9]+\.[0-9]+"> => ast::Value::Float(f64::from_str(<>).unwrap()),
}

Value: ast::Value<'input> = {
    Number,
    String,
    "true" => ast::Value::Boolean(true),
    "false" => ast::Value::Boolean(false),
    "undefined" => ast::Value::Undefined,
    "null" => ast::Value::Null,
};

VariableKind: ast::VariableKind = {
    "string" => ast::VariableKind::String,
    "number" => ast::VariableKind::Number,
};
